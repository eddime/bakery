#!/usr/bin/env bun
/**
 * ü•ê Bakery Asset Embedder (BINARY VERSION)
 * Embeds assets as RAW BINARY (not Base64) for instant loading!
 * 
 * Performance: 
 * - No Base64 decoding needed = INSTANT asset serving
 * - Direct memory access = ZERO overhead
 */

import { readdirSync, statSync, readFileSync, writeFileSync, existsSync } from 'fs';
import { join, relative, extname, resolve } from 'path';

interface EmbeddedFile {
  path: string;
  size: number;
  mimeType: string;
}

function getMimeType(filePath: string): string {
  const ext = extname(filePath).toLowerCase();
  const mimeTypes: Record<string, string> = {
    '.html': 'text/html',
    '.css': 'text/css',
    '.js': 'application/javascript',
    '.json': 'application/json',
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.gif': 'image/gif',
    '.svg': 'image/svg+xml',
    '.webp': 'image/webp',
    '.ico': 'image/x-icon',
    '.woff': 'font/woff',
    '.woff2': 'font/woff2',
    '.ttf': 'font/ttf',
    '.mp3': 'audio/mpeg',
    '.ogg': 'audio/ogg',
    '.wav': 'audio/wav',
    '.mp4': 'video/mp4',
    '.webm': 'video/webm',
  };
  return mimeTypes[ext] || 'application/octet-stream';
}

function getAllFiles(dir: string, baseDir: string): string[] {
  const files: string[] = [];
  
  const items = readdirSync(dir);
  for (const item of items) {
    const fullPath = join(dir, item);
    const stat = statSync(fullPath);
    
    if (stat.isDirectory()) {
      if (item === 'node_modules' || item === '.git' || item === 'dist') continue;
      files.push(...getAllFiles(fullPath, baseDir));
    } else {
      files.push(fullPath);
    }
  }
  
  return files;
}

function toHexArray(buffer: Buffer): string {
  const bytes: string[] = [];
  for (let i = 0; i < buffer.length; i++) {
    bytes.push(`0x${buffer[i].toString(16).padStart(2, '0')}`);
  }
  return bytes.join(',');
}

async function embedAssets(projectDir: string, outputFile: string) {
  console.log('ü•ê Bakery Binary Asset Embedder');
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
  console.log('üìÅ Project:', projectDir);
  
  const srcDir = join(projectDir, 'src');
  const allFiles = getAllFiles(srcDir, srcDir);
  
  // Add bakery.config.json if it exists
  const configJsonPath = join(projectDir, 'bakery.config.json');
  const configJsPath = join(projectDir, 'bakery.config.js');
  
  if (existsSync(configJsonPath)) {
    allFiles.push(configJsonPath);
  } else if (existsSync(configJsPath)) {
    // Convert JS config to JSON for embedding
    console.log('üìù Converting bakery.config.js to JSON...');
    try {
      const absoluteConfigPath = resolve(configJsPath);
      const configModule = await import(`file://${absoluteConfigPath}`);
      const configJson = JSON.stringify(configModule.default, null, 2);
      const tmpPath = join(projectDir, '.bakery.config.json.tmp');
      writeFileSync(tmpPath, configJson);
      allFiles.push(tmpPath);
      console.log('   ‚úÖ Config converted');
    } catch (e: any) {
      console.warn('‚ö†Ô∏è  Failed to load JS config:', e?.message || e);
      console.warn('   Continuing without config...');
    }
  }
  
  console.log(`üì¶ Found ${allFiles.length} files to embed\n`);
  
  const embeddedFiles: EmbeddedFile[] = [];
  let totalSize = 0;
  
  let cppHeader = `// Auto-generated by Bakery Binary Asset Embedder
// Assets are embedded as RAW BINARY for instant loading!

#ifndef BAKERY_EMBEDDED_ASSETS_H
#define BAKERY_EMBEDDED_ASSETS_H

#include <string>
#include <cstring>

namespace bakery {
namespace embedded {

struct Asset {
    const char* path;
    const unsigned char* data; // RAW BINARY (not Base64!)
    size_t size;
    const char* mimeType;
};

`;

  // Embed each file as binary array
  for (let i = 0; i < allFiles.length; i++) {
    const filePath = allFiles[i];
    
    // Special handling for config files
    let relativePath: string;
    if (filePath.endsWith('.bakery.config.json.tmp')) {
      relativePath = 'bakery.config.json';
    } else if (filePath.endsWith('bakery.config.json')) {
      relativePath = 'bakery.config.json';
    } else {
      relativePath = relative(srcDir, filePath);
    }
    
    const content = readFileSync(filePath);
    const mimeType = getMimeType(filePath);
    
    embeddedFiles.push({
      path: relativePath,
      size: content.length,
      mimeType,
    });
    
    totalSize += content.length;
    console.log(`   ‚úÖ ${relativePath} (${(content.length / 1024).toFixed(2)} KB)`);
    
    // Embed as binary array
    cppHeader += `// ${relativePath} (${(content.length / 1024).toFixed(2)} KB)\n`;
    cppHeader += `static const char ASSET_${i}_PATH[] = "${relativePath.replace(/\\/g, '/')}";\n`;
    cppHeader += `static const unsigned char ASSET_${i}_DATA[] = {${toHexArray(content)}};\n`;
    cppHeader += `static const char ASSET_${i}_MIME[] = "${mimeType}";\n\n`;
  }

  // Add asset array
  cppHeader += `static const Asset ASSETS[] = {\n`;
  for (let i = 0; i < embeddedFiles.length; i++) {
    const file = embeddedFiles[i];
    cppHeader += `    { ASSET_${i}_PATH, ASSET_${i}_DATA, ${file.size}, ASSET_${i}_MIME },\n`;
  }
  cppHeader += `};\n\n`;
  
  cppHeader += `static const size_t ASSETS_COUNT = ${embeddedFiles.length};\n\n`;
  
  // Helper function
  cppHeader += `inline const Asset* getAsset(const std::string& path) {
    for (size_t i = 0; i < ASSETS_COUNT; i++) {
        if (path == ASSETS[i].path) {
            return &ASSETS[i];
        }
    }
    return nullptr;
}

} // namespace embedded
} // namespace bakery

#endif // BAKERY_EMBEDDED_ASSETS_H
`;

  writeFileSync(outputFile, cppHeader);
  console.log(`\n‚úÖ Generated: ${outputFile}\n`);
  console.log(`üì¶ ${embeddedFiles.length} files embedded as RAW BINARY`);
  console.log(`üìä Total size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);
  console.log(`‚ö° ZERO Base64 decoding overhead!\n`);
}

// CLI
const projectDir = process.argv[2] || process.cwd();
const outputFile = process.argv[3] || join(projectDir, 'embedded-assets.h');

await embedAssets(projectDir, outputFile);

